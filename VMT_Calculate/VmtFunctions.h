#pragma once

#include <opencv2/imgproc/imgproc.hpp>  
#include <opencv2/core/core.hpp>        // Basic OpenCV structures (cv::Mat, Scalar)
#include <opencv2/highgui/highgui.hpp>  // OpenCV window I/O
#include <fstream>
#include <iostream> // for standard I/O
#include <queue>

#include <QString>

#define I_MAX 255
//#define PREDEFINED_THRESHOLD 150 //156
#define X_SIZE 640
#define Y_SIZE 480
#define Z_SIZE 8000
#define MIN_Z 10
#define MAX_Z Z_SIZE
#define NORMALIZATION_INTERVAL 2000 //(MAX_Z - MIN_Z) // ==> no normalization

//to calculate volume object differences:
#define DEPTH_TOLERANCE 10
#define X_TOLERANCE 0
#define Y_TOLERANCE 0



using namespace std;

class VmtFunctions
{
private:
	static const int dims = 3;
	int *matrixSize;
    unsigned int permittedMinZ;
    unsigned int permittedMaxZ;

	enum DimIndex
	{
        Y = 1,
        X = 0,
		Z = 2
	};

	inline float raw_depth_to_meters(int raw_depth)
	{
        if (raw_depth <= 2047)
			return 1.0 / (raw_depth * -0.0030711016 + 3.3309495161);
		return 0;
	}

    struct VmtInfo
    {
        int numberOfPoints;
        int sizeInX;
        int sizeInY;
        int sizeInZ;
        int maxX;
        int maxY;
        int maxZ;
        int minX;
        int minY;
        int minZ;
    };

public:
	//constructor for 3D VMTs
	VmtFunctions(int xSize = X_SIZE, int ySize = Y_SIZE);
	~VmtFunctions(void);

    //generate a VMT from a video folder and a sliding window (generated by Bingbing's algo, 40frames long)
    cv::SparseMat GenerateSparseVMT(QString videoFolderPath, QString trackFilePath, int downsamplingRate = 1);

	void Print3x3Matrix(const cv::Matx33d& mat);
	void Print3DSparseMatrix(cv::SparseMat sparse_mat);
    void Save3DSparseMatrix(cv::SparseMat sparse_mat, QString filePath);
    void Save3DMatrix(cv::Mat sparse_mat, QString filePath);



protected:
    cv::SparseMat GenerateSparseVolumeObject(QString imagePath, int downsamplingRate = 2);

    //to be used with cropped images (with track files)
    cv::SparseMat GenerateSparseVolumeObject(cv::Mat image, int downsamplingRate = 2);
    cv::Mat GenerateVolumeObject(cv::Mat image, int downsamplingRate = 2);

    cv::SparseMat SubtractSparseMat(const cv::SparseMat& operand1, const cv::SparseMat& operand2,
        int depthTolerance, int xTolerance, int yTolerance);

    vector<cv::SparseMat> CalculateVolumeObjectDifferencesSparse(const vector<cv::SparseMat>& volumeObjects);
    vector<cv::SparseMat> CalculateVolumeObjectDifferencesSparse(const vector<cv::SparseMat>& volumeObjects, int depthTolerance);

    double AttenuationConstantForAnAction(const QList<cv::SparseMat> &volumeObjectsDifferences);
    int MagnitudeOfMotion(const cv::SparseMat& sparseMat);

    cv::SparseMat ConstructVMT(const QList<cv::SparseMat>& volumeObjectDifferences);
//    vector<cv::SparseMat> ConstructVMTs(const vector<cv::SparseMat>& volumeObjectDifferences);

    cv::SparseMat CalculateD_Old(cv::SparseMat lastVolumeObject, cv::SparseMat firstVolumeObject);
    cv::SparseMat CalculateD_New(cv::SparseMat lastVolumeObject, cv::SparseMat firstVolumeObject);
    cv::Vec3i CalculateMomentVector(cv::SparseMat volumeObject);

    double CalculateAlpha(cv::Vec3i motionVector);
    double CalculateBeta(cv::Vec3i motionVector);
    double CalculateTheta(cv::Vec3i motionVector);

    cv::Matx33d CalculateRotationX_alpha(double alpha);
    cv::Matx33d CalculateRotationY_beta(double beta);
    cv::Matx33d CalculateRotationZ_theta(double theta);

    cv::SparseMat RotateVMT(const cv::SparseMat& vmt, const cv::Matx33d& rotationMatrix);
    cv::Mat ProjectVMTOntoXY(const cv::SparseMat& vmt);

    //Get basic info of a 3d sparse mat
    VmtInfo GetVmtInfo(const cv::SparseMat &vmt) const;
    //shrink & trim the 3d sparse mat to get rid of unnecessarily large size
    cv::SparseMat TrimVmt(const cv::SparseMat &vmt);

    cv::SparseMat SpatiallyNormalizeVMT(cv::SparseMat vmt);

};

